package models

import (
	"log"
	"timlink/Godeps/_workspace/src/gopkg.in/mgo.v2/bson"
	"timlink/Godeps/_workspace/src/gopkg.in/mgo.v2"
	"timlink/connection"
	"time"
	"timlink/Godeps/_workspace/src/github.com/yhat/scrape"
  "timlink/Godeps/_workspace/src/golang.org/x/net/html"
  "timlink/Godeps/_workspace/src/golang.org/x/net/html/atom"
  "net/http"
	// "reflect"
)

func RepoAllItems() []Item {
	var items []Item
	var session *mgo.Session
	defer session.Close()
	result := connection.GetCollection("items", session).Find(nil).All(&items)

	if result == nil {
		return items
	} else {
		// fmt.Println(reflect.TypeOf(result))
		return items
	}
}

func RepoFindItem(id string) Item {
	var session *mgo.Session
	defer session.Close()
	c := connection.GetCollection("items", session)
	result := Item{}
	err := c.Find(bson.M{"_id": bson.ObjectIdHex(id)}).One(&result)
	if err != nil {
		return result
		log.Fatal(err)
	}
	return result
}

//this is bad, I don't think it passes race condtions
func (t Item) RepoCreateItem() Item {
	var session *mgo.Session
	defer session.Close()
	c := connection.GetCollection("items", session)
	// This guarantees that t.Id has the bson _id generated by mongo
	t.Id = bson.NewObjectId()
	t.CreatedAt = time.Now()
	t.ParseUrl()
	err := c.Insert(t)

	if err != nil {
		return Item{}
		log.Fatal(err)
	}
	return t
}

func RepoDestroyItem(id string) error {
	var session *mgo.Session
	defer session.Close()
	// if t.Id == id {
	// 	items = append(items[:i], items[i+1:]...)
	// 	return nil
	// }
	return connection.GetCollection("items", session).Remove(bson.M{"_id": bson.ObjectIdHex(id)})

}

func (t *Item) ParseUrl() string {
	resp, err := http.Get(t.Url)
  if err != nil {
      // panic(err)
	}
  root, err := html.Parse(resp.Body)
  if err != nil {
    // panic(err)
  }
  title, ok := scrape.Find(root, scrape.ByTag(atom.Title))
	if ok {
	  // Print the title
	  t.Title = scrape.Text(title)
		return scrape.Text(title)
	} else {
		
		return ""
	}
}